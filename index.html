<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>GPX Voyager üõ∞Ô∏è</title>
    <meta property="og:title" content="GPX Voyager üõ∞Ô∏è" />
    <meta
      property="og:description"
      content="Offline low battery consumption gpx navigation"
    />
    <meta property="og:image" id="og-image" content="" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <link rel="manifest" href="manifest.json" />
    <link rel="apple-touch-icon" id="apple-touch-icon" href="" />
    <link rel="icon" id="favicon" href="" />
    <script>
      // Dynamically create icons and manifest.
      (function createIcons() {
        const svgIconString =
          `<svg xmlns="http://www.w3.org/2000/svg" width="192" height="192" viewBox="0 0 192 192" fill="none"><rect width="192" height="192" rx="40" fill="black"/><path d="M96 32L128 96L96 112L64 96L96 32Z" fill="#ff6b6b"/><path d="M96 160L128 96L96 112L64 96L96 160Z" fill="#d3d3d3"/></svg>`.trim();
        const dataUrl = `data:image/svg+xml;base64,${btoa(svgIconString)}`;
        document.getElementById("favicon").href = dataUrl;
        document.getElementById("apple-touch-icon").href = dataUrl;
        document.getElementById("og-image").content = dataUrl;
        const manifest = {
          name: "GPX Voyager",
          short_name: "Voyager",
          start_url: ".",
          display: "standalone",
          background_color: "#000000",
          theme_color: "#ff6b6b",
          description: "Ïù∏ÌÑ∞ÎÑ∑ Ïó∞Í≤∞ ÏóÜÏù¥ GPX Í≤ΩÎ°úÎ•º Ï∂îÏ†ÅÌïòÎäî Ïõπ Ïï±",
          icons: [{ src: dataUrl, sizes: "192x192", type: "image/svg+xml" }],
        };
        document.querySelector('link[rel="manifest"]').href =
          URL.createObjectURL(
            new Blob([JSON.stringify(manifest)], { type: "application/json" }),
          );
      })();
    </script>
    <style>
      :root {
        --bg-color: #000000;
        --primary-text-color: #d3d3d3;
        --secondary-text-color: #a9a9a9;
        --accent-color: #ff6b6b;
        --gpx-track-color: #a9a9a9;
        --user-path-color: #d3d3d3;
        --marker-color: #ff6b6b;
        --button-bg-color: #000000;
        --button-active-bg-color: #333333;
        --panel-bg-color: rgba(20, 20, 20, 0.95);
      }
      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: var(--bg-color);
        color: var(--primary-text-color);
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu,
          Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        -webkit-tap-highlight-color: transparent;
      }
      #app-container {
        display: flex;
        width: 100%;
        height: 100%;
        background-color: var(--bg-color);
      }
      @media (max-width: 600px), (orientation: portrait) {
        #app-container {
          flex-direction: column;
        }
        #info-panel {
          width: 100%;
          height: 30%;
          flex-shrink: 0;
        }
        #map-container {
          width: 100%;
          height: 70%;
          flex-grow: 1;
        }
        #journey-box {
          flex-direction: row;
          align-items: center;
        }
        #journey-box .sub-info-box .value {
          font-size: clamp(1em, 4vw, 1.5em);
        }
      }
      @media (min-width: 601px) and (orientation: landscape) {
        #app-container {
          flex-direction: row;
        }
        #info-panel {
          width: 30%;
          max-width: 300px;
          height: 100%;
        }
        #map-container {
          width: 70%;
          height: 100%;
        }
        #journey-box {
          flex-direction: column;
        }
        #journey-box .sub-info-box .value {
          font-size: 1.1em;
        }
      }
      #info-panel {
        display: flex;
        flex-direction: column;
        padding: 10px;
        box-sizing: border-box;
      }
      #dashboard {
        flex-grow: 1;
        display: grid;
        grid-template-rows: 1fr 1fr;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        min-height: 0;
      }
      .info-box {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: var(--bg-color);
        border: 1px solid var(--button-active-bg-color);
        border-radius: 8px;
        padding: 10px;
        min-width: 0;
      }
      #speed-box {
        grid-column: 1 / 3;
      }
      #journey-box {
        grid-column: 1 / 2;
        justify-content: space-around;
      }
      #avg-speed-box {
        grid-column: 2 / 3;
      }
      .value {
        font-size: clamp(1.5em, 5vw, 2.2em);
        font-weight: bold;
      }
      .unit,
      .label {
        font-size: clamp(0.7em, 3vw, 0.9em);
        color: var(--secondary-text-color);
      }
      #speed-box .value {
        font-size: clamp(2.5em, 10vw, 4em);
      }
      #journey-box .sub-info-box {
        text-align: center;
      }
      #map-container {
        position: relative;
        background-color: var(--bg-color);
      }
      #map-svg {
        width: 100%;
        height: 100%;
        touch-action: none;
        cursor: grab;
        background-color: var(--bg-color);
        transition: visibility 0.3s;
      }
      #map-svg:active {
        cursor: grabbing;
      }
      #gpx-track-container path,
      #user-path {
        fill: none;
        stroke-linejoin: round;
        stroke-linecap: round;
        vector-effect: non-scaling-stroke;
      }
      #gpx-track-container path {
        stroke-width: 3px;
      }
      #user-path {
        stroke: var(--user-path-color);
        stroke-width: 5px;
      }
      #current-pos-marker {
        fill: var(--marker-color);
        stroke: var(--bg-color);
        stroke-width: 1.5px;
        vector-effect: non-scaling-stroke;
        transform-origin: center;
        pointer-events: none;
      }
      .map-controls-wrapper {
        position: absolute;
        bottom: 15px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 10;
        transition: opacity 0.3s;
      }
      #left-controls {
        left: 15px;
      }
      #right-controls {
        right: 15px;
      }
      #top-right-controls {
        position: absolute;
        top: 15px;
        right: 15px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 10;
        align-items: center;
      }
      .control-btn {
        width: 36px;
        height: 36px;
        background-color: var(--button-bg-color);
        border: 1px solid #444;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        transition:
          background-color 0.2s,
          transform 0.1s;
      }
      .control-btn[data-action^="zoom"] {
        color: #ffffff;
        font-size: 18px;
        font-weight: bold;
      }
      .control-btn:active {
        transform: scale(0.95);
        background-color: var(--button-active-bg-color);
      }
      .control-btn.active {
        background-color: var(--accent-color);
      }
      .control-btn svg {
        width: 20px;
        height: 20px;
        stroke: var(--primary-text-color);
        stroke-width: 2;
        fill: none;
        stroke-linecap: round;
        stroke-linejoin: round;
        pointer-events: none;
      }
      .control-btn.active svg {
        stroke: var(--bg-color);
        fill: var(--bg-color);
      }
      .control-btn[data-action="zoom-fit"] svg {
        fill: var(--primary-text-color);
        stroke-width: 0;
      }
      .control-btn.active [data-action="zoom-fit"] svg,
      .control-btn.active [data-action="toggle-map-mode"] svg,
      .control-btn.active [data-action="center-map"] svg {
        fill: var(--bg-color);
      }
      #menu-btn {
        position: absolute;
        top: 15px;
        left: 15px;
        z-index: 20;
      }
      #menu-panel {
        position: fixed;
        top: 0;
        left: 0;
        width: 300px;
        max-width: 80vw;
        height: 100%;
        background-color: var(--panel-bg-color);
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        box-shadow: 2px 0 10px rgba(0, 0, 0, 0.5);
        transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        transform: translateX(-105%);
        z-index: 1000;
        padding: 20px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        gap: 20px;
        overflow-y: auto;
      }
      #menu-panel.open {
        transform: translateX(0);
      }
      #menu-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        z-index: 999;
        opacity: 0;
        visibility: hidden;
        transition:
          opacity 0.3s,
          visibility 0.3s;
      }
      #menu-overlay.open {
        opacity: 1;
        visibility: visible;
      }
      .menu-section h3 {
        margin-top: 0;
        margin-bottom: 10px;
        color: var(--accent-color);
        font-size: 1.1em;
        border-bottom: 1px solid var(--button-active-bg-color);
        padding-bottom: 5px;
      }
      .menu-btn,
      #gpx-file-input-label {
        display: block;
        width: 100%;
        padding: 12px;
        background-color: var(--button-bg-color);
        color: var(--primary-text-color);
        border: none;
        border-radius: 8px;
        text-align: left;
        font-size: 1em;
        cursor: pointer;
        box-sizing: border-box;
        margin-bottom: 10px;
      }
      #gpx-file-input-label {
        text-align: center;
      }
      #gpx-file-input {
        display: none;
      }
      .setting-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }
      .setting-item select {
        background: var(--button-bg-color);
        color: var(--primary-text-color);
        border: 1px solid var(--button-active-bg-color);
        border-radius: 5px;
        padding: 5px;
      }
      #modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 2000;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.2s;
      }
      #modal.show {
        opacity: 1;
        visibility: visible;
      }
      .modal-content {
        background: var(--panel-bg-color);
        padding: 25px;
        border-radius: 12px;
        width: 80%;
        max-width: 400px;
        text-align: center;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        transform: scale(0.95);
        transition: transform 0.2s;
      }
      #modal.show .modal-content {
        transform: scale(1);
      }
      #modal-title {
        font-size: 1.4em;
        font-weight: bold;
        color: var(--accent-color);
        margin: 0 0 10px 0;
      }
      #modal-message {
        margin: 0 0 20px 0;
        line-height: 1.5;
        color: var(--primary-text-color);
      }
      .modal-close-btn,
      .modal-confirm-btn {
        background: var(--button-bg-color);
        color: var(--primary-text-color);
        border: none;
        padding: 12px 20px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1em;
        transition: background-color 0.2s;
      }
      .modal-close-btn:hover,
      .modal-confirm-btn:hover {
        background-color: var(--button-active-bg-color);
      }
      .modal-confirm-btn {
        background-color: var(--accent-color);
        color: var(--bg-color);
        font-weight: bold;
        margin-left: 10px;
      }
      .toggle-switch {
        display: flex;
        align-items: center;
        cursor: pointer;
      }
      .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      .slider {
        position: relative;
        display: block;
        width: 50px;
        height: 26px;
        background-color: #ccc;
        border-radius: 26px;
        transition: 0.4s;
      }
      .slider:before {
        position: absolute;
        content: "";
        height: 20px;
        width: 20px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        border-radius: 50%;
        transition: 0.4s;
        color: black;
        font-weight: bold;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      input:checked + .slider {
        background-color: var(--accent-color);
      }
      input:checked + .slider:before {
        transform: translateX(24px);
      }
      #lang-toggle:not(:checked) + .slider:before {
        content: "KO";
        font-size: 10px;
      }
      #lang-toggle:checked + .slider:before {
        content: "EN";
        font-size: 10px;
      }
      #invert-compass:not(:checked) + .slider:before {
        content: "-";
        font-size: 18px;
        line-height: 1;
      }
      #invert-compass:checked + .slider:before {
        content: "+";
        font-size: 16px;
        line-height: 1;
      }
      #off-route-warning {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        background-color: rgba(139, 0, 0, 0.8);
        color: white;
        text-align: center;
        padding: 8px 0;
        font-weight: bold;
        z-index: 5;
        display: none;
      }
      #scale-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        color: var(--primary-text-color);
        font-size: 12px;
        text-shadow: 1px 1px 2px black;
        pointer-events: none;
        transition: opacity 0.3s;
      }
      #scale-bar {
        width: 2px; /* Set a fixed width for the vertical bar */
        background-color: var(--primary-text-color);
        border-top: 2px solid var(--primary-text-color); /* Use top/bottom borders for caps */
        border-bottom: 2px solid var(--primary-text-color);
        box-sizing: content-box;
      }

      /* Off-Route Overlay Styles */
      #off-route-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: transparent;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 50;
        visibility: hidden;
        opacity: 0;
        transition:
          opacity 0.3s,
          visibility 0.3s;
        pointer-events: none;
      }
      #off-route-overlay.visible {
        visibility: visible;
        opacity: 1;
      }
      #off-route-arrow {
        width: 25vmin;
        height: 25vmin;
        fill: var(--accent-color);
        transform-origin: center;
      }
      #off-route-distance {
        color: var(--primary-text-color);
        font-size: clamp(1.5em, 5vw, 2.5em);
        font-weight: bold;
        margin-top: 20px;
        text-shadow: 0 0 5px black;
      }
      /* Gradient Legend Styles */
      .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
        font-size: 0.9em;
      }
      .legend-color-box {
        width: 20px;
        height: 20px;
        margin-right: 10px;
        border-radius: 4px;
        border: 1px solid #555;
      }
    </style>
  </head>
  <body>
    <div id="app-container">
      <div id="info-panel">
        <div id="dashboard">
          <div class="info-box" id="speed-box">
            <div class="label" data-i18n="currentSpeed">ÌòÑÏû¨ ÏÜçÎèÑ</div>
            <div>
              <span class="value" id="speed-value">0</span
              ><span class="unit">km/h</span>
            </div>
          </div>
          <div class="info-box" id="journey-box">
            <div class="sub-info-box" id="distance-sub-box">
              <div class="label" data-i18n="totalDistance">ÎàÑÏ†Å Í±∞Î¶¨</div>
              <div>
                <span class="value" id="distance-value">0.00</span
                ><span class="unit">km</span>
              </div>
            </div>
            <div class="sub-info-box" id="time-sub-box">
              <div class="label" data-i18n="totalTime">ÎàÑÏ†Å ÏãúÍ∞Ñ</div>
              <div><span class="value" id="time-value">00:00:00</span></div>
            </div>
          </div>
          <div class="info-box" id="avg-speed-box">
            <div class="label" data-i18n="avgSpeed">ÌèâÍ∑† ÏÜçÎ†•</div>
            <div>
              <span class="value" id="avg-speed-value">0.0</span
              ><span class="unit">km/h</span>
            </div>
          </div>
        </div>
      </div>
      <div id="map-container">
        <svg id="map-svg">
          <g id="map-group">
            <!-- Container for GPX track segments -->
            <g id="gpx-track-container"></g>
            <path id="user-path"></path>
          </g>
          <polygon
            id="current-pos-marker"
            points="0,-60 45,60 -45,60"
            visibility="hidden"
          ></polygon>
        </svg>
        <div id="off-route-overlay">
          <svg id="off-route-arrow" viewBox="0 0 100 100">
            <path d="M50 0 L100 100 L50 75 L0 100 Z" />
          </svg>
          <div id="off-route-distance"></div>
        </div>
        <div id="off-route-warning" data-i18n="offRouteWarning">
          Í≤ΩÎ°úÎ•º Ïù¥ÌÉàÌñàÏäµÎãàÎã§.
        </div>
        <div id="top-right-controls">
          <button
            class="control-btn"
            data-action="toggle-fullscreen"
            title="Ï†ÑÏ≤¥ÌôîÎ©¥"
          >
            <svg viewBox="0 0 24 24">
              <path
                d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"
                fill="currentColor"
              ></path>
            </svg>
          </button>
          <div id="scale-container">
            <div id="scale-label"></div>
            <div id="scale-bar"></div>
          </div>
        </div>
        <div id="left-controls" class="map-controls-wrapper">
          <button class="control-btn" data-action="zoom-in" title="ÌôïÎåÄ">
            +</button
          ><button class="control-btn" data-action="zoom-out" title="Ï∂ïÏÜå">
            -</button
          ><button
            class="control-btn"
            data-action="zoom-reset"
            title="200m Ïä§ÏºÄÏùº"
          >
            0</button
          ><button
            class="control-btn"
            data-action="zoom-fit"
            title="Ï†ÑÏ≤¥ Í≤ΩÎ°ú Î≥¥Í∏∞"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              fill="currentColor"
            >
              <path
                d="M15 3l2.3 2.3-2.89 2.87 1.42 1.42L18.7 6.7 21 9V3zM3 9l2.3-2.3 2.87 2.89 1.42-1.42L6.7 5.3 9 3H3zm6 12l-2.3-2.3 2.89-2.87-1.42-1.42L5.3 17.3 3 15v6zm12-6l-2.3 2.3-2.87-2.89-1.42 1.42L17.3 18.7 15 21h6z"
              ></path>
            </svg>
          </button>
        </div>
        <div id="right-controls" class="map-controls-wrapper">
          <button
            class="control-btn"
            data-action="toggle-map-mode"
            title="ÏßÄÎèÑ Î™®Îìú Ï†ÑÌôò"
          >
            <svg viewBox="0 0 24 24">
              <path d="M12 2L4.5 20.29l.71.71L12 18l6.79 2.99l.71-.71z"></path>
            </svg></button
          ><button
            class="control-btn active"
            data-action="center-map"
            title="ÌòÑÏû¨ ÏúÑÏπòÎ°ú Ï§ëÏïô Ï†ïÎ†¨"
          >
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path
                d="M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4s-1.79-4-4-4zm8.94 3c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"
              ></path>
            </svg>
          </button>
        </div>
        <button class="control-btn" id="menu-btn" data-action="toggle-menu">
          <svg viewBox="0 0 24 24">
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path>
          </svg>
        </button>
      </div>
    </div>
    <div id="menu-overlay"></div>
    <div id="menu-panel">
      <div class="menu-section">
        <h3 data-i18n="fileManagement">ÌååÏùº Í¥ÄÎ¶¨</h3>
        <label
          for="gpx-file-input"
          id="gpx-file-input-label"
          data-i18n="openGpxFile"
          >GPX ÌååÏùº Ïó¥Í∏∞</label
        ><input type="file" id="gpx-file-input" accept=".gpx" />
      </div>
      <div class="menu-section">
        <h3 data-i18n="journeyLog">Ïó¨Ï†ï Í∏∞Î°ù</h3>
        <button
          class="menu-btn"
          data-action="toggle-tracking"
          data-i18n="startTracking"
        >
          Ï∂îÏ†Å ÏãúÏûë</button
        ><button
          class="menu-btn"
          data-action="save-journey"
          data-i18n="saveJourneySummary"
          disabled
        >
          Ïó¨Ï†ï ÏöîÏïΩ Ï†ÄÏû•
        </button>
      </div>
      <div class="menu-section">
        <h3 data-i18n="settings">ÏÑ§Ï†ï</h3>
        <div class="setting-item">
          <label for="update-interval" data-i18n="updateInterval"
            >GPS Í∞±Ïã† Ï£ºÍ∏∞ (Ï¥à)</label
          ><select id="update-interval">
            <option value="1000">1</option>
            <option value="5000" selected>5</option>
            <option value="15000">15</option>
            <option value="30000">30</option>
            <option value="60000">60</option>
            <option value="300000">300</option>
          </select>
        </div>
        <div class="setting-item">
          <label for="compass-interval" data-i18n="compassInterval"
            >ÎÇòÏπ®Î∞ò Í∞±Ïã† Ï£ºÍ∏∞ (Ï¥à)</label
          ><select id="compass-interval">
            <option value="0" data-i18n="realtime">Ïã§ÏãúÍ∞Ñ</option>
            <option value="100">0.1</option>
            <option value="500" selected>0.5</option>
            <option value="1000">1</option>
            <option value="5000">5</option>
          </select>
        </div>
        <div class="setting-item">
          <label for="invert-compass" data-i18n="invertCompass"
            >ÎÇòÏπ®Î∞ò Î∞©Ìñ• Î∞òÏ†Ñ</label
          ><label class="toggle-switch"
            ><input type="checkbox" id="invert-compass" /><span
              class="slider"
            ></span
          ></label>
        </div>
        <div class="setting-item">
          <label data-i18n="language">Ïñ∏Ïñ¥</label
          ><label class="toggle-switch"
            ><input type="checkbox" id="lang-toggle" /><span
              class="slider"
            ></span
          ></label>
        </div>
      </div>
      <div class="menu-section">
        <h3 data-i18n="diagnostics">ÏßÑÎã® Î∞è Ï¥àÍ∏∞Ìôî</h3>
        <button class="menu-btn" data-action="gps-test" data-i18n="gpsTest">
          GPS ÌÖåÏä§Ìä∏
        </button>
        <button
          class="menu-btn"
          data-action="retry-wakelock"
          data-i18n="retryWakelock"
        >
          ÌôîÎ©¥ Í∫ºÏßê Î∞©ÏßÄ Ïû¨ÏãúÎèÑ
        </button>
        <button
          class="menu-btn"
          data-action="reset-all"
          data-i18n="resetAll"
          style="background-color: #5d2a2a"
        >
          Î™®Îì† Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
        </button>
      </div>
      <div class="menu-section" id="gradient-legend-section">
        <h3 data-i18n="gradientLegend">Í≤ΩÏÇ¨ÎèÑ Î≤îÎ°Ä</h3>
        <div id="gradient-legend-container"></div>
      </div>
    </div>
    <div id="modal">
      <div class="modal-content">
        <h2 id="modal-title"></h2>
        <p id="modal-message"></p>
        <div id="modal-buttons">
          <button id="modal-close-btn" data-i18n="close">Îã´Í∏∞</button>
        </div>
      </div>
    </div>

    <script>
      // Service Worker Registration
      if ("serviceWorker" in navigator) {
        const swScript = `const CACHE_NAME = 'gps-voyager-cache-v28'; self.addEventListener('install', e => e.waitUntil(caches.open(CACHE_NAME).then(c => c.add(location.pathname)))); self.addEventListener('fetch', e => e.respondWith(caches.match(e.request).then(r => r || fetch(e.request)))); self.addEventListener('activate', e => e.waitUntil(caches.keys().then(keys => Promise.all(keys.map(key => key !== CACHE_NAME ? caches.delete(key) : undefined)))));`;
        navigator.serviceWorker.register(
          URL.createObjectURL(
            new Blob([swScript], { type: "application/javascript" }),
          ),
        );
      }

      document.addEventListener("DOMContentLoaded", () => {
        const $ = (selector) => document.querySelector(selector);

        const app = {
          infoPanel: $("#info-panel"),
          mapContainer: $("#map-container"),
          menuPanel: $("#menu-panel"),
          menuOverlay: $("#menu-overlay"),
          speedValue: $("#speed-value"),
          distanceValue: $("#distance-value"),
          avgSpeedValue: $("#avg-speed-value"),
          timeValue: $("#time-value"),
          mapSvg: $("#map-svg"),
          mapGroup: $("#map-group"),
          gpxTrackContainer: $("#gpx-track-container"),
          userPath: $("#user-path"),
          marker: $("#current-pos-marker"),
          trackBtn: $('[data-action="toggle-tracking"]'),
          mapModeBtn: $('[data-action="toggle-map-mode"]'),
          centerMapBtn: $('[data-action="center-map"]'),
          saveBtn: $('[data-action="save-journey"]'),
          gpxFileInput: $("#gpx-file-input"),
          updateIntervalSelect: $("#update-interval"),
          compassIntervalSelect: $("#compass-interval"),
          invertCompassToggle: $("#invert-compass"),
          retryWakelockBtn: $('[data-action="retry-wakelock"]'),
          modal: $("#modal"),
          modalTitle: $("#modal-title"),
          modalMessage: $("#modal-message"),
          modalButtons: $("#modal-buttons"),
          langToggle: $("#lang-toggle"),
          offRouteWarning: $("#off-route-warning"),
          scaleContainer: $("#scale-container"),
          scaleLabel: $("#scale-label"),
          scaleBar: $("#scale-bar"),
          offRouteOverlay: $("#off-route-overlay"),
          offRouteArrow: $("#off-route-arrow"),
          offRouteDistance: $("#off-route-distance"),
          gradientLegendContainer: $("#gradient-legend-container"),
        };

        const state = {
          gpx: { points: [], bounds: null, metersPerUnit: 1 },
          tracking: {
            isActive: false,
            startTime: null,
            gpsTimeoutId: null,
            timerId: null,
            totalDistance: 0,
            elapsedTime: 0,
            previousSnap: null,
            isOffRoute: false,
          },
          position: {
            current: null,
            heading: 0,
            snapped: { point: null, index: -1 },
            headingHistory: [],
            speedHistory: [],
            lastCompassUpdate: 0,
            interpolated: null,
            lastSpeed: 0,
          },
          map: {
            mode: "north-up",
            isCentered: true,
            viewBox: { x: 0, y: 0, width: 1000, height: 1000 },
            zoomLevel: 2,
            panning: { isDown: false, startX: 0, startY: 0, vbX: 0, vbY: 0 },
          },
          screen: { orientation: 0 },
          settings: {
            updateInterval: 5000,
            compassInterval: 0.5,
            language: "ko",
            invertCompass: true,
          },
          permissions: { gps: "prompt" },
          wakeLock: null,
          interpolation: {
            timerId: null,
            lastGpsUpdateTime: 0,
            pathSegment: [],
            travelledDistanceMeters: 0,
            intervalDurationSeconds: 0,
            startPoint: null,
            endPoint: null,
          },
        };

        const CONSTANTS = {
          EARTH_RADIUS_KM: 6371,
          HEADING_SMOOTHING_SAMPLES: 5,
          SPEED_SMOOTHING_SAMPLES: 4,
          ZOOM_SCALES: [50, 100, 200, 500, 1000, 5000, "fit"],
          TARGET_MARKER_REAL_WORLD_HEIGHT_M: 10,
          ORIGINAL_MARKER_SVG_HEIGHT: 120,
          INTERPOLATION_DISTANCE_THRESHOLD_KM: 0.001, // 1 meter
        };

        const GRADIENT_COLORS = [
          {
            threshold: 15,
            color: "#500000",
            label: "15% ~",
            label_en: "15% ~",
          },
          {
            threshold: 10,
            color: "#FF0000",
            label: "10 ~ 15%",
            label_en: "10 ~ 15%",
          },
          {
            threshold: 6,
            color: "#FFA500",
            label: "6 ~ 10%",
            label_en: "6 ~ 10%",
          },
          {
            threshold: 3,
            color: "#FFCF50",
            label: "3 ~ 6%",
            label_en: "3 ~ 6%",
          },
          {
            threshold: 1,
            color: "#FFFF00",
            label: "1 ~ 3%",
            label_en: "1 ~ 3%",
          },
          {
            threshold: 0,
            color: "#FFFFA0",
            label: "0 ~ 1%",
            label_en: "0 ~ 1%",
          },
          {
            threshold: -1,
            color: "#CDF8E6",
            label: "-1 ~ 0%",
            label_en: "-1 ~ 0%",
          },
          {
            threshold: -4,
            color: "#ADD8E6",
            label: "-4 ~ -1%",
            label_en: "-4 ~ -1%",
          },
          {
            threshold: -8,
            color: "#4169E1",
            label: "-8 ~ -4%",
            label_en: "-8 ~ -4%",
          },
          {
            threshold: -Infinity,
            color: "#00008B",
            label: "~ -8%",
            label_en: "~ -8%",
          },
        ];

        const i18n = {
          ko: {
            currentSpeed: "ÌòÑÏû¨ ÏÜçÎèÑ",
            totalDistance: "ÎàÑÏ†Å Í±∞Î¶¨",
            totalTime: "ÎàÑÏ†Å ÏãúÍ∞Ñ",
            avgSpeed: "ÌèâÍ∑† ÏÜçÎ†•",
            fileManagement: "ÌååÏùº Í¥ÄÎ¶¨",
            openGpxFile: "GPX ÌååÏùº Ïó¥Í∏∞",
            journeyLog: "Ïó¨Ï†ï Í∏∞Î°ù",
            startTracking: "Ï∂îÏ†Å ÏãúÏûë",
            stopTracking: "Ï∂îÏ†Å Ï§ëÏßÄ",
            saveJourneySummary: "Ïó¨Ï†ï ÏöîÏïΩ Ï†ÄÏû•",
            settings: "ÏÑ§Ï†ï",
            updateInterval: "GPS Í∞±Ïã† Ï£ºÍ∏∞ (Ï¥à)",
            compassInterval: "ÎÇòÏπ®Î∞ò Í∞±Ïã† Ï£ºÍ∏∞ (Ï¥à)",
            realtime: "Ïã§ÏãúÍ∞Ñ",
            language: "Ïñ∏Ïñ¥",
            invertCompass: "ÎÇòÏπ®Î∞ò Î∞©Ìñ• Î∞òÏ†Ñ",
            diagnostics: "ÏßÑÎã® Î∞è Ï¥àÍ∏∞Ìôî",
            gpsTest: "GPS ÌÖåÏä§Ìä∏",
            retryWakelock: "ÌôîÎ©¥ Í∫ºÏßê Î∞©ÏßÄ Ïû¨ÏãúÎèÑ",
            wakelockSuccess: "ÌôîÎ©¥ Í∫ºÏßê Î∞©ÏßÄÍ∞Ä ÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§.",
            resetAll: "Î™®Îì† Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî",
            close: "Îã´Í∏∞",
            error: "Ïò§Î•ò",
            alert: "ÏïåÎ¶º",
            warning: "Í≤ΩÍ≥†",
            gpxFileError:
              "GPX ÌååÏùºÏóê Ïú†Ìö®Ìïú Ìä∏Îûô(&lt;trkpt&gt;) Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.",
            fileReadError: "ÌååÏùºÏùÑ ÏùΩÎäî ÎèÑÏ§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
            permissionDenied:
              "GPS Í∂åÌïúÏù¥ Ï∞®Îã®ÎêòÏóàÏäµÎãàÎã§. Î∏åÎùºÏö∞Ï†Ä ÏÑ§Ï†ïÏóêÏÑú ÏúÑÏπò Í∂åÌïúÏùÑ ÌóàÏö©Ìï¥Ï£ºÏÑ∏Ïöî.",
            gpsError: "ÏúÑÏπò Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.",
            noGpxFile: "Î®ºÏ†Ä GPX ÌååÏùºÏùÑ Î°úÎìúÌï¥Ï£ºÏÑ∏Ïöî.",
            noJourneyData: "Ï†ÄÏû•Ìï† Ïó¨Ï†ï Í∏∞Î°ùÏù¥ ÏóÜÏäµÎãàÎã§.",
            resetConfirm: "Î™®Îì† Îç∞Ïù¥ÌÑ∞Î•º Ï¥àÍ∏∞ÌôîÌïòÏãúÍ≤†ÏäµÎãàÍπå?",
            resetConfirmBtn: "Ï¥àÍ∏∞Ìôî",
            cancelBtn: "Ï∑®ÏÜå",
            wakelockFail:
              "ÌôîÎ©¥ Í∫ºÏßê Î∞©ÏßÄ Í∏∞Îä•ÏùÑ ÌôúÏÑ±ÌôîÌï† Ïàò ÏóÜÏäµÎãàÎã§. Î∏åÎùºÏö∞Ï†Ä ÏÑ§Ï†ï ÎòêÎäî Î∞∞ÌÑ∞Î¶¨ Ï†àÏïΩ Î™®ÎìúÎ•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.",
            gpsTestSuccess: "GPS ÌÖåÏä§Ìä∏ ÏÑ±Í≥µ",
            offRouteWarning: "Í≤ΩÎ°úÎ•º Ïù¥ÌÉàÌñàÏäµÎãàÎã§.",
            resetSuccess: "Ï¥àÍ∏∞ÌôîÍ∞Ä ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§.",
            gradientLegend: "Í≤ΩÏÇ¨ÎèÑ Î≤îÎ°Ä",
          },
          en: {
            currentSpeed: "Current Speed",
            totalDistance: "Distance",
            totalTime: "Time",
            avgSpeed: "Avg. Speed",
            fileManagement: "File Management",
            openGpxFile: "Open GPX File",
            journeyLog: "Journey Log",
            startTracking: "Start Tracking",
            stopTracking: "Stop Tracking",
            saveJourneySummary: "Save Journey Summary",
            settings: "Settings",
            updateInterval: "GPS Update Interval (sec)",
            compassInterval: "Compass Update Rate (sec)",
            realtime: "Real-time",
            language: "Language",
            invertCompass: "Invert Compass Direction",
            diagnostics: "Diagnostics",
            gpsTest: "GPS Test",
            retryWakelock: "Retry Screen Wake Lock",
            wakelockSuccess: "Screen wake lock has been activated.",
            resetAll: "Reset All Data",
            close: "Close",
            error: "Error",
            alert: "Alert",
            warning: "Warning",
            gpxFileError:
              "No valid track points (&lt;trkpt&gt;) found in the GPX file.",
            fileReadError: "An error occurred while reading the file.",
            permissionDenied:
              "GPS permission denied. Please enable it in your browser settings.",
            gpsError: "Could not retrieve location information.",
            noGpxFile: "Please load a GPX file first.",
            noJourneyData: "There is no journey data to save.",
            resetConfirm: "Are you sure you want to reset all data?",
            resetConfirmBtn: "Reset",
            cancelBtn: "Cancel",
            wakelockFail:
              "Could not enable screen wake lock. Please check browser settings or battery saver mode.",
            gpsTestSuccess: "GPS Test Successful",
            offRouteWarning: "Off route.",
            resetSuccess: "Reset complete.",
            gradientLegend: "Gradient Legend",
          },
        };

        const populateGradientLegend = (lang) => {
          const container = app.gradientLegendContainer;
          if (!container) return;
          container.innerHTML = "";
          const labelKey = lang === "en" ? "label_en" : "label";
          GRADIENT_COLORS.forEach((item) => {
            const legendItem = document.createElement("div");
            legendItem.className = "legend-item";

            const colorBox = document.createElement("div");
            colorBox.className = "legend-color-box";
            colorBox.style.backgroundColor = item.color;

            const label = document.createElement("span");
            label.textContent = item[labelKey];

            legendItem.appendChild(colorBox);
            legendItem.appendChild(label);
            container.appendChild(legendItem);
          });
        };

        const setLanguage = (lang) => {
          state.settings.language = lang;
          document.documentElement.lang = lang;
          app.langToggle.checked = lang === "en";
          document.querySelectorAll("[data-i18n]").forEach((el) => {
            const key = el.dataset.i18n;
            if (i18n[lang][key]) el.textContent = i18n[lang][key];
          });
          app.trackBtn.textContent = state.tracking.isActive
            ? i18n[lang].stopTracking
            : i18n[lang].startTracking;
          populateGradientLegend(lang);
        };

        const toRad = (deg) => (deg * Math.PI) / 180;
        const showModal = (titleKey, messageKey, buttons = []) => {
          const lang = state.settings.language;
          app.modalTitle.textContent = i18n[lang][titleKey] || titleKey;
          app.modalMessage.innerHTML = i18n[lang][messageKey] || messageKey;
          app.modalButtons.innerHTML = "";
          if (buttons.length > 0) {
            buttons.forEach((b) => {
              const btn = document.createElement("button");
              btn.textContent = i18n[lang][b.textKey];
              btn.className = b.class || "modal-close-btn";
              btn.onclick = () => {
                hideModal();
                if (b.onClick) b.onClick();
              };
              app.modalButtons.appendChild(btn);
            });
          } else {
            app.modalButtons.innerHTML = `<button class="modal-close-btn">${i18n[lang].close}</button>`;
            app.modalButtons.querySelector("button").onclick = hideModal;
          }
          app.modal.classList.add("show");
        };
        const hideModal = () => app.modal.classList.remove("show");

        const handleGpxFile = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (e) => parseGpx(e.target.result);
          reader.onerror = () => showModal("error", "fileReadError");
          reader.readAsText(file);
          toggleMenu();
        };

        const parseGpx = (gpxString) => {
          const parser = new DOMParser();
          const xmlDoc = parser.parseFromString(gpxString, "application/xml");
          const trkpts = xmlDoc.querySelectorAll("trkpt");
          if (trkpts.length === 0) return showModal("error", "gpxFileError");
          resetData(false);
          state.gpx.points = Array.from(trkpts).map((pt) => ({
            lat: parseFloat(pt.getAttribute("lat")),
            lon: parseFloat(pt.getAttribute("lon")),
            ele: parseFloat(pt.querySelector("ele")?.textContent || 0),
          }));
          calculateGpxBounds();
          projectAndRenderGpx();
          app.trackBtn.disabled = false;
        };

        const calculateGpxBounds = () => {
          if (state.gpx.points.length === 0) return;
          state.gpx.bounds = state.gpx.points.reduce(
            (acc, p) => ({
              minLat: Math.min(acc.minLat, p.lat),
              minLon: Math.min(acc.minLon, p.lon),
              maxLat: Math.max(acc.maxLat, p.lat),
              maxLon: Math.max(acc.maxLon, p.lon),
            }),
            { minLat: 90, minLon: 180, maxLat: -90, maxLon: -180 },
          );
        };
        const projectPoint = (lat, lon) => {
          const { minLat, minLon, maxLat, maxLon } = state.gpx.bounds;
          const mapSize = 10000;
          const x =
            maxLon - minLon === 0
              ? mapSize / 2
              : ((lon - minLon) / (maxLon - minLon)) * mapSize;
          const mercN = Math.log(Math.tan(Math.PI / 4 + toRad(lat) / 2));
          const minMercN = Math.log(Math.tan(Math.PI / 4 + toRad(minLat) / 2));
          const maxMercN = Math.log(Math.tan(Math.PI / 4 + toRad(maxLat) / 2));
          const y =
            maxMercN - minMercN === 0
              ? mapSize / 2
              : ((maxMercN - mercN) / (maxMercN - minMercN)) * mapSize;
          return { x, y };
        };

        const getGradientColor = (gradient) => {
          for (const item of GRADIENT_COLORS) {
            if (gradient >= item.threshold) {
              return item.color;
            }
          }
          return GRADIENT_COLORS[GRADIENT_COLORS.length - 1].color; // Fallback
        };

        const projectAndRenderGpx = () => {
          if (state.gpx.points.length < 2) return;
          app.gpxTrackContainer.innerHTML = "";
          let totalDistanceMeters = 0;
          let projectedDist = 0;
          const fragment = document.createDocumentFragment();
          for (let i = 0; i < state.gpx.points.length - 1; i++) {
            const p1 = state.gpx.points[i];
            const p2 = state.gpx.points[i + 1];
            const p1_proj = projectPoint(p1.lat, p1.lon);
            const p2_proj = projectPoint(p2.lat, p2.lon);
            const elevationChange = p2.ele - p1.ele;
            const horizontalDistance = haversineDistance(p1, p2) * 1000;
            totalDistanceMeters += horizontalDistance;
            projectedDist += Math.sqrt(
              (p2_proj.x - p1_proj.x) ** 2 + (p2_proj.y - p1_proj.y) ** 2,
            );
            const gradient =
              horizontalDistance > 0
                ? (elevationChange / horizontalDistance) * 100
                : 0;
            const color = getGradientColor(gradient);
            const path = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "path",
            );
            path.setAttribute(
              "d",
              `M ${p1_proj.x} ${p1_proj.y} L ${p2_proj.x} ${p2_proj.y}`,
            );
            path.setAttribute("stroke", color);
            fragment.appendChild(path);
          }
          app.gpxTrackContainer.appendChild(fragment);
          state.gpx.metersPerUnit =
            projectedDist > 0 ? totalDistanceMeters / projectedDist : 1;
          setZoom("fit");
        };

        const haversineDistance = (p1, p2) => {
          if (!p1 || !p2) return 0;
          const dLat = toRad(p2.lat - p1.lat),
            dLon = toRad(p2.lon - p1.lon);
          const a =
            Math.sin(dLat / 2) ** 2 +
            Math.cos(toRad(p1.lat)) *
              Math.cos(toRad(p2.lat)) *
              Math.sin(dLon / 2) ** 2;
          return (
            CONSTANTS.EARTH_RADIUS_KM *
            2 *
            Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
          );
        };

        const getDistanceAlongGpxPath = (startSnap, endSnap) => {
          if (
            !startSnap ||
            !endSnap ||
            !startSnap.point ||
            !endSnap.point ||
            startSnap.index < 0 ||
            endSnap.index < 0
          ) {
            return 0;
          }

          if (startSnap.index > endSnap.index) {
            return haversineDistance(startSnap.point, endSnap.point);
          }

          if (startSnap.index === endSnap.index) {
            return haversineDistance(startSnap.point, endSnap.point);
          }

          let distance = 0;
          const startSegmentEnd = state.gpx.points[startSnap.index + 1];
          if (startSegmentEnd) {
            distance += haversineDistance(startSnap.point, startSegmentEnd);
          }
          for (let i = startSnap.index + 1; i < endSnap.index; i++) {
            const p1 = state.gpx.points[i];
            const p2 = state.gpx.points[i + 1];
            if (p1 && p2) {
              distance += haversineDistance(p1, p2);
            }
          }
          const endSegmentStart = state.gpx.points[endSnap.index];
          if (endSegmentStart) {
            distance += haversineDistance(endSegmentStart, endSnap.point);
          }
          return distance;
        };

        // Bearing calculation function
        function bearing(lat1, lon1, lat2, lon2) {
          const toRad = (deg) => (deg * Math.PI) / 180;
          const toDeg = (rad) => (rad * 180) / Math.PI;

          const lat1Rad = toRad(lat1);
          const lon1Rad = toRad(lon1);
          const lat2Rad = toRad(lat2);
          const lon2Rad = toRad(lon2);

          const deltaLon = lon2Rad - lon1Rad;

          const y = Math.sin(deltaLon) * Math.cos(lat2Rad);
          const x =
            Math.cos(lat1Rad) * Math.sin(lat2Rad) -
            Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(deltaLon);

          let brng = Math.atan2(y, x);

          brng = toDeg(brng);
          if (brng < 0) brng += 360;

          if (state.settings.invertCompass) {
            return -brng;
          } else {
            return brng;
          }
        }

        const findClosestPointOnGpx = (p) => {
          let closestPoint = null,
            minDistance = Infinity,
            closestIndex = -1;
          for (let i = 0; i < state.gpx.points.length - 1; i++) {
            const { point, distance } = findClosestPointOnSegment(
              p,
              state.gpx.points[i],
              state.gpx.points[i + 1],
            );
            if (distance < minDistance) {
              minDistance = distance;
              closestPoint = point;
              closestIndex = i;
            }
          }
          return {
            point: closestPoint || state.gpx.points[0],
            distance: minDistance,
            index: closestIndex,
          };
        };

        const findClosestPointOnSegment = (p, a, b) => {
          const ap = { x: p.lon - a.lon, y: p.lat - a.lat },
            ab = { x: b.lon - a.lon, y: b.lat - a.lat };
          let t =
            ab.x ** 2 + ab.y ** 2 === 0
              ? 0
              : (ap.x * ab.x + ap.y * ab.y) / (ab.x ** 2 + ab.y ** 2);
          t = Math.max(0, Math.min(1, t));
          const closest = {
            lat: a.lat + ab.y * t,
            lon: a.lon + ab.x * t,
            ele: a.ele + (b.ele - a.ele) * t,
          };
          return { point: closest, distance: haversineDistance(p, closest) };
        };

        const requestWakeLock = async (showFeedback = false) => {
          if (!("wakeLock" in navigator)) {
            if (showFeedback) showModal("alert", "wakelockFail");
            return;
          }
          try {
            if (state.wakeLock) await state.wakeLock.release();
            state.wakeLock = await navigator.wakeLock.request("screen");
            state.wakeLock.addEventListener("release", () => {
              state.wakeLock = null;
              console.log("Wake Lock released");
            });
            if (showFeedback) showModal("alert", "wakelockSuccess");
          } catch (err) {
            console.error(`${err.name}, ${err.message}`);
            if (showFeedback) showModal("alert", "wakelockFail");
          }
        };

        const checkGpsPermission = async () => {
          if (!navigator.permissions) return;
          try {
            const result = await navigator.permissions.query({
              name: "geolocation",
            });
            state.permissions.gps = result.state;
            result.onchange = () => (state.permissions.gps = result.state);
          } catch (e) {
            console.warn("Permission API not supported.");
          }
        };

        const toggleTracking = async () => {
          if (state.gpx.points.length === 0)
            return showModal("alert", "noGpxFile");
          state.tracking.isActive ? stopTracking() : await startTracking();
        };

        const startTracking = async () => {
          await checkGpsPermission();
          if (state.permissions.gps === "denied")
            return showModal("error", "permissionDenied");
          state.tracking.isActive = true;
          app.trackBtn.textContent = i18n[state.settings.language].stopTracking;
          app.trackBtn.style.backgroundColor = "var(--accent-color)";
          app.retryWakelockBtn.style.display = "block";
          if (!state.tracking.startTime) {
            state.tracking.startTime = Date.now();
          }
          state.tracking.timerId = setInterval(updateTimer, 1000);
          updatePosition();
          setZoom(2);
          requestWakeLock(false);
        };

        const stopTracking = () => {
          state.tracking.isActive = false;
          app.trackBtn.textContent =
            i18n[state.settings.language].startTracking;
          app.trackBtn.style.backgroundColor = "";
          app.retryWakelockBtn.style.display = "none";
          clearTimeout(state.tracking.gpsTimeoutId);
          clearInterval(state.tracking.timerId);
          stopInterpolation();
          state.tracking.gpsTimeoutId = state.tracking.timerId = null;
          app.saveBtn.disabled = !state.tracking.startTime;
          if (state.wakeLock) {
            state.wakeLock.release();
            state.wakeLock = null;
          }
        };

        const scheduleNextPositionUpdate = () => {
          if (!state.tracking.isActive) return;
          clearTimeout(state.tracking.gpsTimeoutId);
          state.tracking.gpsTimeoutId = setTimeout(
            updatePosition,
            state.settings.updateInterval,
          );
        };

        const updatePosition = () => {
          if (!state.tracking.isActive) return;
          navigator.geolocation.getCurrentPosition(onGpsSuccess, onGpsError, {
            enableHighAccuracy: true,
            timeout: 15000,
            maximumAge: 0,
          });
        };

        const onGpsSuccess = (position) => {
          try {
            const now = performance.now();

            state.position.current = position;
            const { latitude, longitude } = position.coords;
            const closest = findClosestPointOnGpx({
              lat: latitude,
              lon: longitude,
            });
            state.position.snapped = {
              point: closest.point,
              index: closest.index,
            };

            const offRouteDistance = haversineDistance(
              { lat: latitude, lon: longitude },
              closest.point,
            );
            state.tracking.isOffRoute = offRouteDistance > 0.1;
            app.offRouteWarning.style.display = state.tracking.isOffRoute
              ? "block"
              : "none";

            stopInterpolation();

            if (
              state.tracking.previousSnap &&
              state.tracking.previousSnap.point &&
              !state.tracking.isOffRoute
            ) {
              const distanceMoved = getDistanceAlongGpxPath(
                state.tracking.previousSnap,
                state.position.snapped,
              );
              state.tracking.totalDistance += distanceMoved;

              const timeElapsedSeconds =
                (now - state.interpolation.lastGpsUpdateTime) / 1000;

              if (timeElapsedSeconds > 0) {
                const speedMps = (distanceMoved * 1000) / timeElapsedSeconds;
                state.position.lastSpeed = speedMps * 3.6;
              } else {
                state.position.lastSpeed = 0;
              }

              state.position.speedHistory.push(state.position.lastSpeed);
              if (
                state.position.speedHistory.length >
                CONSTANTS.SPEED_SMOOTHING_SAMPLES
              ) {
                state.position.speedHistory.shift();
              }

              const isSignificantMove =
                distanceMoved > CONSTANTS.INTERPOLATION_DISTANCE_THRESHOLD_KM;
              const isLongInterval = timeElapsedSeconds > 1;

              if (isLongInterval && isSignificantMove) {
                const avgSpeed =
                  state.position.speedHistory.length > 0
                    ? state.position.speedHistory.reduce((a, b) => a + b, 0) /
                      state.position.speedHistory.length
                    : 0;

                const predictedDistanceKm =
                  (avgSpeed / 3600) * timeElapsedSeconds;

                const predictedNextSnap = findPointAlongGpxPath(
                  state.tracking.previousSnap,
                  state.position.snapped,
                  predictedDistanceKm,
                );

                if (predictedNextSnap) {
                  state.interpolation.intervalDurationSeconds =
                    timeElapsedSeconds;
                  const pathSegmentGeo = getPathSegmentGeo(
                    state.position.snapped,
                    predictedNextSnap,
                  );
                  state.interpolation.pathSegment = pathSegmentGeo.map((p) =>
                    projectPoint(p.lat, p.lon),
                  );

                  if (state.interpolation.pathSegment.length > 0) {
                    state.interpolation.startPoint = projectPoint(
                      state.position.snapped.point.lat,
                      state.position.snapped.point.lon,
                    );
                    state.interpolation.endPoint = projectPoint(
                      predictedNextSnap.point.lat,
                      predictedNextSnap.point.lon,
                    );

                    state.interpolation.travelledDistanceMeters = 0;
                    for (
                      let i = 0;
                      i < state.interpolation.pathSegment.length - 1;
                      i++
                    ) {
                      const p1 = state.interpolation.pathSegment[i];
                      const p2 = state.interpolation.pathSegment[i + 1];
                      state.interpolation.travelledDistanceMeters += Math.sqrt(
                        Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2),
                      );
                    }

                    if (state.interpolation.travelledDistanceMeters > 0) {
                      startInterpolation();
                    }
                  }
                }
              }
            }

            state.interpolation.lastGpsUpdateTime = now;
            state.tracking.previousSnap = state.position.snapped;

            const newProjectedPoint = projectPoint(
              state.position.snapped.point.lat,
              state.position.snapped.point.lon,
            );
            const userPathD = app.userPath.getAttribute("d") || "";
            app.userPath.setAttribute(
              "d",
              `${userPathD}${userPathD ? "L" : "M"}${newProjectedPoint.x},${newProjectedPoint.y}`,
            );
            updateDashboard(
              state.position.lastSpeed,
              state.tracking.totalDistance,
              state.tracking.elapsedTime,
            );

            updateMap();
          } catch (e) {
            console.error("Error during onGpsSuccess:", e);
          } finally {
            scheduleNextPositionUpdate();
          }
        };

        const onGpsError = (error) => {
          showModal("error", "gpsError");
          scheduleNextPositionUpdate();
        };

        const handleOrientationChange = () => {
          state.screen.orientation =
            window.orientation ||
            (screen.orientation && screen.orientation.angle) ||
            0;
        };

        const updateOffRouteCompass = () => {
          if (
            !state.tracking.isOffRoute ||
            !state.position.current ||
            !state.position.snapped.point
          )
            return;

          const { latitude, longitude } = state.position.current.coords;
          const closestCoordOnGpx = findClosestPointOnGpx({
            lat: latitude,
            lon: longitude,
          });
          const distMeters =
            haversineDistance(
              {
                lat: latitude,
                lon: longitude,
              },
              closestCoordOnGpx.point,
            ) * 1000;
          app.offRouteDistance.textContent =
            distMeters >= 1000
              ? `${(distMeters / 1000).toFixed(1)} km`
              : `${distMeters.toFixed(0)} m`;

          // --- Start of change ---
          // Calculate the bearing from the current position to the closest point on the track
          const bearingToTrack = bearing(
            latitude,
            longitude,
            closestCoordOnGpx.point.lat,
            closestCoordOnGpx.point.lon,
          );

          // Adjust the arrow rotation based on the user's heading
          // The arrow should point towards the track relative to the direction the user is facing
          let arrowRotation = bearingToTrack - state.position.heading;
          if (arrowRotation < 0) arrowRotation += 360;
          arrowRotation = arrowRotation % 360;

          const offRouteArrowTransform = `rotate(${arrowRotation}deg)`;
          app.offRouteArrow.style.transform = offRouteArrowTransform;
        };

        const handleDeviceOrientation = (e) => {
          const now = Date.now();
          if (
            state.settings.compassInterval > 0 &&
            now - state.position.lastCompassUpdate <
              state.settings.compassInterval
          )
            return;
          state.position.lastCompassUpdate = now;

          let rawHeading = e.webkitCompassHeading || e.alpha;
          if (typeof rawHeading !== "number" || isNaN(rawHeading)) return;

          let correctedHeading = rawHeading - state.screen.orientation;

          state.position.headingHistory.push(correctedHeading);
          if (
            state.position.headingHistory.length >
            CONSTANTS.HEADING_SMOOTHING_SAMPLES
          ) {
            state.position.headingHistory.shift();
          }
          const sinSum = state.position.headingHistory.reduce(
            (sum, h) => sum + Math.sin(toRad(h)),
            0,
          );
          const cosSum = state.position.headingHistory.reduce(
            (sum, h) => sum + Math.cos(toRad(h)),
            0,
          );
          const avgRad = Math.atan2(sinSum, cosSum);
          let avgDeg = (avgRad * 180) / Math.PI;
          if (avgDeg < 0) avgDeg += 360;

          if (state.settings.invertCompass) {
            state.position.heading = -avgDeg;
          } else {
            state.position.heading = avgDeg;
          }

          if (state.tracking.isOffRoute) {
            updateOffRouteCompass();
          }
          if (state.position.snapped.point || state.position.current) {
            updateMap();
          }
        };

        const updateDashboard = (speed, distance, time) => {
          app.speedValue.textContent = (speed || 0).toFixed(1);
          app.distanceValue.textContent = distance.toFixed(2);
          app.avgSpeedValue.textContent =
            time > 0 ? (distance / (time / 3600)).toFixed(1) : "0.0";
        };

        const updateTimer = () => {
          if (!state.tracking.startTime) return;
          state.tracking.elapsedTime = Math.floor(
            (Date.now() - state.tracking.startTime) / 1000,
          );
          const h = String(
            Math.floor(state.tracking.elapsedTime / 3600),
          ).padStart(2, "0");
          const m = String(
            Math.floor((state.tracking.elapsedTime % 3600) / 60),
          ).padStart(2, "0");
          const s = String(state.tracking.elapsedTime % 60).padStart(2, "0");
          app.timeValue.textContent = `${h}:${m}:${s}`;
        };

        const updateScaleBar = () => {
          if (
            state.gpx.points.length === 0 ||
            !state.gpx.metersPerUnit ||
            CONSTANTS.ZOOM_SCALES[state.map.zoomLevel] === "fit"
          ) {
            app.scaleContainer.style.opacity = "0";
            return;
          }
          app.scaleContainer.style.opacity = "1";
          const viewWidthInMeters =
            state.map.viewBox.width * state.gpx.metersPerUnit;
          const mapPixelWidth = app.mapSvg.getBoundingClientRect().width;
          if (mapPixelWidth <= 0) return;
          const pixelsPerMeter = mapPixelWidth / viewWidthInMeters;
          let idealDistanceMeters = 80 / pixelsPerMeter;
          const magnitude = Math.pow(
            10,
            Math.floor(Math.log10(idealDistanceMeters)),
          );
          const residual = idealDistanceMeters / magnitude;
          let niceDistance;
          if (residual < 1.5) niceDistance = 1 * magnitude;
          else if (residual < 3.5) niceDistance = 2 * magnitude;
          else if (residual < 7.5) niceDistance = 5 * magnitude;
          else niceDistance = 10 * magnitude;

          // The calculation for the length in pixels is the same,
          // but now it will be applied to the height.
          const barLengthPixels = niceDistance * pixelsPerMeter;
          app.scaleBar.style.height = `${barLengthPixels}px`; // Apply to height
          app.scaleBar.style.width = "2px"; // Keep width fixed

          app.scaleLabel.textContent =
            niceDistance >= 1000
              ? `${niceDistance / 1000} km`
              : `${Math.round(niceDistance)} m`;
        };

        const updateMap = () => {
          try {
            if (state.tracking.isOffRoute) {
              app.offRouteOverlay.classList.add("visible");
              updateOffRouteCompass();
            } else {
              app.offRouteOverlay.classList.remove("visible");
            }

            let positionToDisplay, positionForCentering;

            if (state.interpolation.timerId && state.position.interpolated) {
              positionToDisplay = state.position.interpolated;
              positionForCentering = state.position.interpolated;
            } else if (state.position.snapped.point) {
              const proj = projectPoint(
                state.position.snapped.point.lat,
                state.position.snapped.point.lon,
              );
              positionToDisplay = proj;
              positionForCentering = proj;
            } else {
              updateScaleBar();
              return;
            }

            if (app.marker.getAttribute("visibility") === "hidden") {
              app.marker.setAttribute("visibility", "visible");
              if (state.gpx.points.length > 0) setZoom(2);
            }

            const desiredMarkerSvgHeight =
              CONSTANTS.TARGET_MARKER_REAL_WORLD_HEIGHT_M /
              state.gpx.metersPerUnit;
            const scaleFactor =
              desiredMarkerSvgHeight / CONSTANTS.ORIGINAL_MARKER_SVG_HEIGHT;
            const p1_scaled = `0,${-60 * scaleFactor}`;
            const p2_scaled = `${45 * scaleFactor},${60 * scaleFactor}`;
            const p3_scaled = `${-45 * scaleFactor},${60 * scaleFactor}`;
            app.marker.setAttribute(
              "points",
              `${p1_scaled} ${p2_scaled} ${p3_scaled}`,
            );

            const vb = state.map.viewBox;
            let mapGroupTransform = "";
            let markerTransform = "";
            const markerRotation =
              state.map.mode === "head-up" ? 0 : state.position.heading;

            const mapRotation = -state.position.heading;

            if (state.map.isCentered) {
              const screenMarkerX = vb.x + vb.width * 0.5;
              const screenMarkerY = vb.y + vb.height * 0.8;
              markerTransform = `translate(${screenMarkerX}, ${screenMarkerY}) rotate(${markerRotation})`;
              if (state.map.mode === "head-up") {
                mapGroupTransform = `translate(${screenMarkerX}, ${screenMarkerY}) rotate(${mapRotation}) translate(${-positionForCentering.x}, ${-positionForCentering.y})`;
              } else {
                mapGroupTransform = `translate(${screenMarkerX - positionForCentering.x}, ${screenMarkerY - positionForCentering.y})`;
              }
            } else {
              markerTransform = `translate(${positionToDisplay.x}, ${positionToDisplay.y}) rotate(${markerRotation})`;
              if (state.map.mode === "head-up") {
                const centerX = vb.x + vb.width / 2;
                const centerY = vb.y + vb.height / 2;
                mapGroupTransform = `rotate(${mapRotation}, ${centerX}, ${centerY})`;
              }
            }

            app.marker.setAttribute("transform", markerTransform);
            app.mapGroup.setAttribute("transform", mapGroupTransform);
            updateScaleBar();
          } catch (e) {
            console.error("Error during updateMap:", e);
          }
        };

        const setZoom = (levelOrMode) => {
          if (state.gpx.points.length === 0) return;
          let newLevel;
          if (levelOrMode === "in")
            newLevel = Math.max(0, state.map.zoomLevel - 1);
          else if (levelOrMode === "out")
            newLevel = Math.min(
              CONSTANTS.ZOOM_SCALES.length - 2,
              state.map.zoomLevel + 1,
            );
          else if (levelOrMode === "fit")
            newLevel = CONSTANTS.ZOOM_SCALES.length - 1;
          else if (typeof levelOrMode === "number") newLevel = levelOrMode;
          else newLevel = state.map.zoomLevel;
          if (
            newLevel === state.map.zoomLevel &&
            typeof levelOrMode !== "number" &&
            levelOrMode !== "fit"
          )
            return;
          state.map.zoomLevel = newLevel;
          const vb = state.map.viewBox;
          const ratio = app.mapSvg.clientHeight / app.mapSvg.clientWidth || 1;
          if (CONSTANTS.ZOOM_SCALES[newLevel] === "fit") {
            const pathBounds = app.gpxTrackContainer.getBBox();
            if (pathBounds.width > 0 && pathBounds.height > 0) {
              vb.x = pathBounds.x - pathBounds.width * 0.05;
              vb.y = pathBounds.y - pathBounds.height * 0.05;
              vb.width = pathBounds.width * 1.1;
              vb.height = pathBounds.height * 1.1;
            }
          } else {
            const centerPoint =
              state.position.snapped.point || state.gpx.points[0];
            const center = projectPoint(centerPoint.lat, centerPoint.lon);
            const newWidthProjected =
              CONSTANTS.ZOOM_SCALES[newLevel] / state.gpx.metersPerUnit;
            vb.width = newWidthProjected;
            vb.height = newWidthProjected * ratio;
            vb.x = center.x - vb.width / 2;
            vb.y = center.y - vb.height / 2;
          }
          app.mapSvg.setAttribute(
            "viewBox",
            `${vb.x} ${vb.y} ${vb.width} ${vb.height}`,
          );
          updateMap();
        };

        function findPointAlongGpxPath(previousSnap, currentSnap, distanceKm) {
          if (
            !previousSnap ||
            !currentSnap ||
            !currentSnap.point ||
            distanceKm <= 0
          )
            return null;

          let direction = 1; // 1 for forward, -1 for backward

          if (previousSnap.point && previousSnap.index !== -1) {
            if (currentSnap.index > previousSnap.index) {
              direction = 1;
            } else if (currentSnap.index < previousSnap.index) {
              direction = -1;
            } else {
              // Same segment
              const segmentStart = state.gpx.points[currentSnap.index];
              const distToPrev = haversineDistance(
                segmentStart,
                previousSnap.point,
              );
              const distToCurr = haversineDistance(
                segmentStart,
                currentSnap.point,
              );
              if (distToCurr < distToPrev) {
                direction = -1;
              }
            }
          }

          let distanceToTravelKm = distanceKm;
          let startIndex = currentSnap.index;
          let startPoint = currentSnap.point;

          if (direction === 1) {
            // Forward
            const currentSegmentEnd = state.gpx.points[startIndex + 1];
            if (!currentSegmentEnd) return currentSnap;

            let remainingOnSegmentKm = haversineDistance(
              startPoint,
              currentSegmentEnd,
            );

            if (distanceToTravelKm <= remainingOnSegmentKm) {
              const fraction =
                remainingOnSegmentKm > 0
                  ? distanceToTravelKm / remainingOnSegmentKm
                  : 0;
              const newLat =
                startPoint.lat +
                (currentSegmentEnd.lat - startPoint.lat) * fraction;
              const newLon =
                startPoint.lon +
                (currentSegmentEnd.lon - startPoint.lon) * fraction;
              return { point: { lat: newLat, lon: newLon }, index: startIndex };
            }

            distanceToTravelKm -= remainingOnSegmentKm;

            for (let i = startIndex + 1; i < state.gpx.points.length - 1; i++) {
              const segmentStart = state.gpx.points[i];
              const segmentEnd = state.gpx.points[i + 1];
              const segmentLengthKm = haversineDistance(
                segmentStart,
                segmentEnd,
              );

              if (distanceToTravelKm <= segmentLengthKm) {
                const fraction =
                  segmentLengthKm > 0
                    ? distanceToTravelKm / segmentLengthKm
                    : 0;
                const newLat =
                  segmentStart.lat +
                  (segmentEnd.lat - segmentStart.lat) * fraction;
                const newLon =
                  segmentStart.lon +
                  (segmentEnd.lon - segmentStart.lon) * fraction;
                return { point: { lat: newLat, lon: newLon }, index: i };
              }
              distanceToTravelKm -= segmentLengthKm;
            }
            return {
              point: state.gpx.points[state.gpx.points.length - 1],
              index: state.gpx.points.length - 2,
            };
          } else {
            // Backward (direction === -1)
            const currentSegmentStart = state.gpx.points[startIndex];
            if (!currentSegmentStart) return currentSnap;

            let remainingOnSegmentKm = haversineDistance(
              startPoint,
              currentSegmentStart,
            );

            if (distanceToTravelKm <= remainingOnSegmentKm) {
              const fraction =
                remainingOnSegmentKm > 0
                  ? distanceToTravelKm / remainingOnSegmentKm
                  : 0;
              const newLat =
                startPoint.lat -
                (startPoint.lat - currentSegmentStart.lat) * fraction;
              const newLon =
                startPoint.lon -
                (startPoint.lon - currentSegmentStart.lon) * fraction;
              return { point: { lat: newLat, lon: newLon }, index: startIndex };
            }

            distanceToTravelKm -= remainingOnSegmentKm;

            for (let i = startIndex - 1; i >= 0; i--) {
              const segmentStart = state.gpx.points[i];
              const segmentEnd = state.gpx.points[i + 1];
              const segmentLengthKm = haversineDistance(
                segmentStart,
                segmentEnd,
              );

              if (distanceToTravelKm <= segmentLengthKm) {
                const fraction =
                  segmentLengthKm > 0
                    ? distanceToTravelKm / segmentLengthKm
                    : 0;
                const newLat =
                  segmentEnd.lat -
                  (segmentEnd.lat - segmentStart.lat) * fraction;
                const newLon =
                  segmentEnd.lon -
                  (segmentEnd.lon - segmentStart.lon) * fraction;
                return { point: { lat: newLat, lon: newLon }, index: i };
              }
              distanceToTravelKm -= segmentLengthKm;
            }
            return { point: state.gpx.points[0], index: 0 };
          }
        }

        const startInterpolation = () => {
          stopInterpolation();
          state.interpolation.timerId = setInterval(interpolationLoop, 1000);
        };

        const stopInterpolation = () => {
          if (state.interpolation.timerId) {
            clearInterval(state.interpolation.timerId);
            state.interpolation.timerId = null;
          }
        };

        const interpolationLoop = () => {
          const elapsedSinceUpdate =
            (performance.now() - state.interpolation.lastGpsUpdateTime) / 1000;
          const intervalDuration = state.interpolation.intervalDurationSeconds;

          if (elapsedSinceUpdate >= intervalDuration) {
            stopInterpolation();
            state.position.interpolated = state.interpolation.endPoint;
            updateMap();
            return;
          }

          const progress = elapsedSinceUpdate / intervalDuration;
          const distanceToTravel =
            state.interpolation.travelledDistanceMeters * progress;
          let cumulativeDistance = 0;
          let interpolatedPoint = state.interpolation.startPoint;

          for (let i = 0; i < state.interpolation.pathSegment.length - 1; i++) {
            const segmentStart = state.interpolation.pathSegment[i];
            const segmentEnd = state.interpolation.pathSegment[i + 1];
            const segmentLength = Math.sqrt(
              Math.pow(segmentEnd.x - segmentStart.x, 2) +
                Math.pow(segmentEnd.y - segmentStart.y, 2),
            );

            if (cumulativeDistance + segmentLength >= distanceToTravel) {
              const distanceIntoSegment = distanceToTravel - cumulativeDistance;
              const fractionOfSegment =
                segmentLength === 0 ? 0 : distanceIntoSegment / segmentLength;
              interpolatedPoint = {
                x:
                  segmentStart.x +
                  (segmentEnd.x - segmentStart.x) * fractionOfSegment,
                y:
                  segmentStart.y +
                  (segmentEnd.y - segmentStart.y) * fractionOfSegment,
              };
              break;
            }
            cumulativeDistance += segmentLength;
          }
          state.position.interpolated = interpolatedPoint;
          updateMap();
        };

        const getPathSegmentGeo = (startSnap, endSnap) => {
          if (
            !startSnap ||
            !endSnap ||
            !startSnap.point ||
            !endSnap.point ||
            startSnap.index === -1 ||
            endSnap.index === -1
          ) {
            return [startSnap.point, endSnap.point].filter(Boolean);
          }

          const path = [startSnap.point];

          if (startSnap.index < endSnap.index) {
            // Forward
            for (let i = startSnap.index + 1; i <= endSnap.index; i++) {
              path.push(state.gpx.points[i]);
            }
          } else if (startSnap.index > endSnap.index) {
            // Backward
            for (let i = startSnap.index; i > endSnap.index; i--) {
              path.push(state.gpx.points[i]);
            }
          }

          path.push(endSnap.point);

          return path.filter((p, i) => {
            if (i === 0) return true;
            const prev = path[i - 1];
            return p.lat !== prev.lat || p.lon !== prev.lon;
          });
        };

        const toggleMenu = () => {
          app.menuPanel.classList.toggle("open");
          app.menuOverlay.classList.toggle("open");
        };
        const handleAction = (e) => {
          const target = e.target.closest("[data-action]");
          if (!target) return;
          const action = target.dataset.action;
          if (
            [
              "center-map",
              "toggle-map-mode",
              "zoom-reset",
              "zoom-in",
              "zoom-out",
              "zoom-fit",
            ].includes(action)
          ) {
            if (state.gpx.points.length === 0)
              return showModal("alert", "noGpxFile");
          }
          switch (action) {
            case "toggle-menu":
              toggleMenu();
              break;
            case "toggle-tracking":
              toggleTracking();
              break;
            case "gps-test":
              navigator.geolocation.getCurrentPosition(
                (p) =>
                  showModal(
                    "gpsTestSuccess",
                    `Lat: ${p.coords.latitude.toFixed(5)}<br>Lon: ${p.coords.longitude.toFixed(5)}`,
                  ),
                onGpsError,
              );
              break;
            case "reset-all":
              showModal("warning", "resetConfirm", [
                { textKey: "cancelBtn" },
                {
                  textKey: "resetConfirmBtn",
                  class: "modal-confirm-btn",
                  onClick: () => resetData(true),
                },
              ]);
              break;
            case "retry-wakelock":
              requestWakeLock(true);
              break;
            case "center-map":
              state.map.isCentered = true;
              app.centerMapBtn.classList.add("active");
              updateMap();
              break;
            case "toggle-map-mode":
              state.map.mode =
                state.map.mode === "north-up" ? "head-up" : "north-up";
              app.mapModeBtn.classList.toggle(
                "active",
                state.map.mode === "head-up",
              );
              if (state.map.mode === "head-up" && !state.map.isCentered) {
                state.map.isCentered = true;
                app.centerMapBtn.classList.add("active");
              }
              if (state.position.snapped.point || state.position.current)
                updateMap();
              break;
            case "zoom-in":
              setZoom("in");
              break;
            case "zoom-out":
              setZoom("out");
              break;
            case "zoom-reset":
              state.map.isCentered = true;
              app.centerMapBtn.classList.add("active");
              setZoom(2);
              break;
            case "zoom-fit":
              if (state.map.mode === "head-up") {
                state.map.mode = "north-up";
                app.mapModeBtn.classList.remove("active");
              }
              setZoom("fit");
              break;
            case "toggle-fullscreen":
              document.fullscreenElement
                ? document.exitFullscreen()
                : document.documentElement
                    .requestFullscreen()
                    .catch((err) => console.error(err));
              break;
            case "save-journey":
              exportJourneyData();
              break;
          }
        };
        const handleMapPan = (e) => {
          e.preventDefault();
          const p = state.map.panning;
          const currentX = e.type.includes("touch")
            ? e.touches[0].clientX
            : e.clientX;
          const currentY = e.type.includes("touch")
            ? e.touches[0].clientY
            : e.clientY;
          if (p.isDown) {
            state.map.isCentered = false;
            app.centerMapBtn.classList.remove("active");
            if (state.map.mode !== "head-up")
              app.mapGroup.setAttribute("transform", "");
            const scale = app.mapSvg.clientWidth / state.map.viewBox.width;
            const dx = (currentX - p.startX) / scale;
            const dy = (currentY - p.startY) / scale;
            state.map.viewBox.x = p.vbX - dx;
            state.map.viewBox.y = p.vbY - dy;
            app.mapSvg.setAttribute(
              "viewBox",
              `${state.map.viewBox.x} ${state.map.viewBox.y} ${state.map.viewBox.width} ${state.map.viewBox.height}`,
            );
            updateMap();
          }
        };
        const handleDoubleClick = (e) => {
          if (e.target.closest("#info-panel"))
            $('[data-action="toggle-fullscreen"]').click();
          if (e.target.closest("#map-container")) {
            $('[data-action="center-map"]').click();
            $('[data-action="zoom-reset"]').click();
          }
        };

        const resetData = (fullReset) => {
          if (state.tracking.isActive) stopTracking();

          Object.assign(state.tracking, {
            isActive: false,
            startTime: null,
            gpsTimeoutId: null,
            timerId: null,
            totalDistance: 0,
            elapsedTime: 0,
            previousSnap: null,
            isOffRoute: false,
          });
          Object.assign(state.position, {
            current: null,
            heading: 0,
            snapped: { point: null, index: -1 },
            headingHistory: [],
            lastCompassUpdate: 0,
            interpolated: null,
            lastSpeed: 0,
            speedHistory: [],
          });
          Object.assign(state.map, {
            mode: "north-up",
            isCentered: true,
            viewBox: { x: 0, y: 0, width: 1000, height: 1000 },
            zoomLevel: 2,
          });
          stopInterpolation();

          app.userPath.setAttribute("d", "");
          app.marker.setAttribute("visibility", "hidden");
          app.offRouteWarning.style.display = "none";
          app.offRouteOverlay.classList.remove("visible");
          updateDashboard(0, 0, 0);
          app.timeValue.textContent = "00:00:00";
          app.saveBtn.disabled = true;
          app.mapModeBtn.classList.remove("active");
          app.centerMapBtn.classList.add("active");
          app.trackBtn.style.backgroundColor = "";
          app.retryWakelockBtn.style.display = "none";
          app.mapGroup.setAttribute("transform", "");
          app.mapGroup.setAttribute("visibility", "visible");
          app.mapSvg.setAttribute("viewBox", "0 0 1000 1000");
          app.mapSvg.style.visibility = "visible";

          app.gpxTrackContainer.innerHTML = "";

          if (fullReset) {
            Object.assign(state.gpx, {
              points: [],
              bounds: null,
              metersPerUnit: 1,
            });
            app.trackBtn.disabled = true;
            app.gpxFileInput.value = "";
            const defaultLang = navigator.language.startsWith("ko")
              ? "ko"
              : "en";
            state.settings.language = defaultLang;
            state.settings.updateInterval = 5000;
            state.settings.compassInterval = 0.5;
            state.settings.invertCompass = true;
            app.updateIntervalSelect.value = "5000";
            app.compassIntervalSelect.value = "500";
            app.invertCompassToggle.checked = true;
            setLanguage(defaultLang);
            showModal("alert", "resetSuccess");
          }
          updateScaleBar();
        };

        const exportJourneyData = () => {
          if (!state.tracking.startTime)
            return showModal("error", "noJourneyData");
          const journeyData = {
            startTime: new Date(state.tracking.startTime).toISOString(),
            endTime: new Date().toISOString(),
            totalDistanceKm: state.tracking.totalDistance,
            elapsedTimeSec: state.tracking.elapsedTime,
            avgSpeedKmh:
              state.tracking.elapsedTime > 0
                ? state.tracking.totalDistance /
                  (state.tracking.elapsedTime / 3600)
                : 0,
          };
          const blob = new Blob([JSON.stringify(journeyData, null, 2)], {
            type: "application/json",
          });
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = `journey_summary_${Date.now()}.json`;
          a.click();
          URL.revokeObjectURL(a.href);
        };

        const init = () => {
          const userLang = navigator.language.startsWith("ko") ? "ko" : "en";
          setLanguage(userLang);
          app.invertCompassToggle.checked = true;
          state.settings.invertCompass = true; // Sync state
          checkGpsPermission();
          handleOrientationChange();
          window.addEventListener("orientationchange", handleOrientationChange);
          let resizeTimeout;
          window.addEventListener("resize", () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(updateScaleBar, 100);
          });
          document.body.addEventListener("click", handleAction);
          document.body.addEventListener("dblclick", handleDoubleClick);
          app.menuOverlay.addEventListener("click", toggleMenu);
          app.gpxFileInput.addEventListener("change", handleGpxFile);
          app.updateIntervalSelect.onchange = (e) => {
            state.settings.updateInterval = parseInt(e.target.value, 10);
            if (state.tracking.isActive) {
              clearTimeout(state.tracking.gpsTimeoutId);
              updatePosition();
            }
          };
          app.compassIntervalSelect.onchange = (e) =>
            (state.settings.compassInterval = parseInt(e.target.value, 10));
          app.invertCompassToggle.addEventListener("change", (e) => {
            state.settings.invertCompass = e.target.checked;
            updateMap();
          });
          const orientationEvent =
            "ondeviceorientationabsolute" in window
              ? "deviceorientationabsolute"
              : "deviceorientation";
          if (window.DeviceOrientationEvent)
            window.addEventListener(
              orientationEvent,
              handleDeviceOrientation,
              true,
            );
          app.modal.onclick = (e) => {
            if (
              e.target.classList.contains("modal-close-btn") ||
              e.target === app.modal
            )
              hideModal();
          };
          app.mapSvg.addEventListener("pointerdown", (e) => {
            if (e.button !== 0) return;
            state.map.panning.isDown = true;
            state.map.panning.startX = e.clientX;
            state.map.panning.startY = e.clientY;
            state.map.panning.vbX = state.map.viewBox.x;
            state.map.panning.vbY = state.map.viewBox.y;
          });
          app.mapSvg.addEventListener("pointermove", handleMapPan);
          window.addEventListener(
            "pointerup",
            () => (state.map.panning.isDown = false),
          );
          app.langToggle.addEventListener("change", (e) =>
            setLanguage(e.target.checked ? "en" : "ko"),
          );
          app.trackBtn.disabled = true;
          app.retryWakelockBtn.style.display = "none";
          updateScaleBar();
        };

        init();
      });
    </script>
  </body>
</html>
